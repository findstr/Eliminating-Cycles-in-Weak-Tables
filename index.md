# 使用弱表避免循环引用（Eliminating Cycles in Weak Tables）

------

- 作者：Alexandra Barros, Roberto Ierusalimschy
- 译者：[重归混沌](http://blog.gotocoding.com)

## 摘要：

*弱引用* 为与垃圾回收器交互提供了一种优雅的机制。*弱引用* 的大多数典型应用都是通过*弱表*来实现的（例如:Java中的WeakHasMap）。 然而大多数*弱表*都有一个很苛刻的限制：只要*弱表*中key和valu相互循环引用，那么即使已经没有外部数据对他们进行引用，这些数据也不会被垃圾因收器回收。这最终会为在某类应用中使用弱表带来困难。

在本文中，我们呈现了在lua编程语言中，是如何克服这个困难的。我们的方法包含了一个对表的ephemerons机制的变种。为了提供这种机制，我们修改了lua虚拟机的垃圾回收器。带着这个修改后的垃圾回收器，我们可以来这个解决弱表中的循环引用是实现是否高效和可用。

#### 关键字:垃圾回惧，弱表，弱引用

#### 分类: D.3.3


## 1 介绍

带有自动内存管理的编程语言一般都会在*客户程序*和*垃圾回收器*提供一个接口. 这个接口一般都会允许客户程序与垃圾回收器进行交互，典型的代表是*finalizers(终结器)*[Atkins and Nackman 1988,
Boehm 2003, Dybvig et al. 1993, Hayes 1992]和*weak reference(弱引用)*[Leal 2005].

finalizer是一种特殊的方法，垃圾回收器在回收某个对象所占用的内存之前会自动调用finalizer函数。这样的方法被用在许多活动中，包括对象高速缓存的管理和释放由服务或其他程序提供的资源。 Finalizers有异步特性。Bloch[Bloch 2001] 说finalizer是不可预测的、高危的、不必要的，并且对程序的效率是有负作用的。然而，Boehm[Boehm 2003]认为finalizer是必要的，并且他的异步性并不一定会导致不健全的过程。

弱引用是一种不会阻止垃圾回收器回收对象的引用。许多有垃圾回收的编程语言至少从80年代起就提出了支持弱引用[PARC 1985, Rees et al. 1984]. 在一些其他的应用中，弱引用可以被用来实现finalization机制， 与传统的finalizers相结合可以避免很多问题。根据编程语言和垃圾收集管理器的实现方式的不同，对finalizer的支持甚至都变得不是必要的。

弱引用越来越重要，促使我们寻找一个关键的问题的解决方案：在弱表中循环。一个典型的例子，这个问题与*属性表*一起出现。通常，我们想动态的向一个对象增加一些属性，但是又不想修改他的类(class).一个常见的做法是使用*属性表* 。 在属性表中，一个对象的引用被插入作为搜索key(索引key）,而与该关键字相关联值被用来指定这个额外属性的值。 然而，如果表中所有引用都是平凡的，插入一个新的*key/value对*将会阻止将会阻止被key所引用的对象被回收。 解决这个问题最好的办法就是通过弱引用实现的*弱表* 。一个弱表由多个*weak pair(键/值对)* 组成， weak pair的第一个元素为key(键)是一个弱引用，weak pair的第二个元素为value(值）是一个平凡的引用。在这种方式下，增加一个属性到一个对象中去，并不会阻止垃圾回收器对这个对象的回收。

然而，在在弱表中循环依然会发生在大部分编程语言中：由于key和value循环引用的存在，会导致这些循环引用的key和value即使客户程序已经对这些循环的key和value没有任何引用的情况下，也不能被很好的回收。这些循环的一个常见的场景包含，一个value引用了与他相关联的key。例如：一个属性表(被实现为弱表)可能将函数和他们各自的模块相关联，以便它可以说明给定函数属于哪个模块。每个模块又会引用他们自己模块内的函数，在这个属性表中将不会有任何key和value被回收掉。这最终导致对内存的巨大浪费并且会增加使用弱表的负担。这个问题已经被发现，例如，在编程语言像Java[SUN 2006] 和 Lua[Ierusalimschy 2006]. 通过Lua的讨论列表，我们可以发现这个问题被抱怨的频率。

对于这个问题可以通过一种叫做*emphermerons*机制解决，这个机制被Hayes[Hayes 1997]提出。 Jones[Jones et al. 1999]为Hashell[Glasgow 2007]编程语言独立实现了一个类似的解决方案，这个方案与ephemerons机制有相同的核心思想。

由于其对在Hashell上的成功，我们为Lua设计并实现了这种机制的一个变种。作为一个起点，我们认真的学习了一个Kayes[Kayes 1997]描述的算法。在我们学习的过程中，我们很好奇它为什么没有被大多数语言所实现，实现它所带的来影响是什么。最后，我们实现了一个Lua 垃圾回收器的变种以便我们可以评测这种影响。 我们的目的是为了展示，通过为lua引入ephemerons可以很容易的解决循环在弱表中产生的问题。 并且通过这么做我们可以改善弱引用机制。



