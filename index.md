# 使用弱表消除循环引用（Eliminating Cycles in Weak Tables）

------

- 作者：Alexandra Barros, Roberto Ierusalimschy
- 译者：[重归混沌](http://blog.gotocoding.com)

## 摘要：

*弱引用* 为与垃圾回收器交互提供了一种优雅的机制。*弱引用* 的大多数典型应用都是通过*弱表*来实现的（例如:Java中的WeakHasMap）。 然而大多数*弱表*都有一个很苛刻的限制：只要*弱表*中key和valu相互循环引用，那么即使已经没有外部数据对他们进行引用，这些数据也不会被垃圾因收器回收。这最终会为在某类应用中使用弱表带来困难。

在本文中，我们呈现了在lua编程语言中，是如何克服这个困难的。我们的方法包含了一个对表的ephemerons机制的变种。为了提供这种机制，我们修改了lua虚拟机的垃圾回收器。带着这个修改后的垃圾回收器，我们可以来这个解决弱表中的循环引用是实现是否高效和可用。

#### 关键字:垃圾回收，弱表，弱引用

#### 分类: D.3.3


## 1 介绍

带有自动内存管理的编程语言一般都会在*客户程序*和*垃圾回收器*提供一个接口. 这个接口一般都会允许客户程序与垃圾回收器进行交互，典型的代表是*finalizers(终结器)*[Atkins and Nackman 1988,
Boehm 2003, Dybvig et al. 1993, Hayes 1992]和*weak reference(弱引用)*[Leal 2005].

finalizer是一种特殊的方法，垃圾回收器在回收某个对象所占用的内存之前会自动调用finalizer函数。这样的方法被用在许多活动中，包括对象高速缓存的管理和释放由服务或其他程序提供的资源。 Finalizers有异步特性。Bloch[Bloch 2001] 说finalizer是不可预测的、高危的、不必要的，并且对程序的效率是有负作用的。然而，Boehm[Boehm 2003]认为finalizer是必要的，并且他的异步性并不一定会导致不健全的过程。

弱引用是一种不会阻止垃圾回收器回收对象的引用。许多有垃圾回收的编程语言至少从80年代起就提出了支持弱引用[PARC 1985, Rees et al. 1984]. 在一些其他的应用中，弱引用可以被用来实现finalization机制， 与传统的finalizers相结合可以避免很多问题。根据编程语言和垃圾收集管理器的实现方式的不同，对finalizer的支持甚至都变得不是必要的。

弱引用越来越重要，促使我们寻找一个关键的问题的解决方案：在弱表中循环。一个典型的例子，这个问题与*属性表*一起出现。通常，我们想动态的向一个对象增加一些属性，但是又不想修改他的类(class).一个常见的做法是使用*属性表* 。 在属性表中，一个对象的引用被插入作为搜索key(索引key）,而与该关键字相关联值被用来指定这个额外属性的值。 然而，如果表中所有引用都是平凡的，插入一个新的*key/value对*将会阻止将会阻止被key所引用的对象被回收。 解决这个问题最好的办法就是通过弱引用实现的*弱表* 。一个弱表由多个*weak pair(键/值对)* 组成， weak pair的第一个元素为key(键)是一个弱引用，weak pair的第二个元素为value(值）是一个平凡的引用。在这种方式下，增加一个属性到一个对象中去，并不会阻止垃圾回收器对这个对象的回收。

然而，在在弱表中循环依然会发生在大部分编程语言中：由于key和value循环引用的存在，会导致这些循环引用的key和value即使客户程序已经对这些循环的key和value没有任何引用的情况下，也不能被很好的回收。这些循环的一个常见的场景包含，一个value引用了与他相关联的key。例如：一个属性表(被实现为弱表)可能将函数和他们各自的模块相关联，以便它可以说明给定函数属于哪个模块。每个模块又会引用他们自己模块内的函数，在这个属性表中将不会有任何key和value被回收掉。这最终导致对内存的巨大浪费并且会增加使用弱表的负担。这个问题已经被发现，例如，在编程语言像Java[SUN 2006] 和 Lua[Ierusalimschy 2006]. 通过Lua的讨论列表，我们可以发现这个问题被抱怨的频率。

对于这个问题可以通过一种叫做*emphermerons*机制解决，这个机制被Hayes[Hayes 1997]提出。 Jones[Jones et al. 1999]为Hashell[Glasgow 2007]编程语言独立实现了一个类似的解决方案，这个方案与ephemerons机制有相同的核心思想。

由于其对在Hashell上的成功，我们为Lua设计并实现了这种机制的一个变种。作为一个起点，我们认真的学习了一个Kayes[Kayes 1997]描述的算法。在我们学习的过程中，我们很好奇它为什么没有被大多数语言所实现，实现它所带的来影响是什么。最后，我们实现了一个Lua 垃圾回收器的变种以便我们可以评测这种影响。 我们的目的是为了展示，通过为lua引入ephemerons可以很容易的解决循环在弱表中产生的问题。 并且通过这么做我们可以改善弱引用机制。


## 2 弱表

弱表是包含一个或多个*weak pair*的数据结构。 这一个weak pair中， 第一个元素（key） 被弱引用保留，第二个元素（value）被平凡引用保留。在Java编程语言中，一个弱表是通过类**WeakHashMap**来实现的，使用弱引用。 在Lua中，弱表是一个原始机制（它可以在需要的时侯，被用来实现常归弱引用）。然而，在Lua中，我们不仅可以构造包含weak pairs的弱表，还可以构造强key和弱value构成的弱表，或者弱key和弱value。

在Lua中，每个table都有一个metatable(元表), 这个metatable用来控件table的一些行为。metatable中的每个字段都会控制table的特定方面。而字段**__mode**是一个字符串类型用于table的弱引用。如果字符串包含字符'k', 则所有key都是弱引用；如果他包含字符'v', 那么所有的value都是弱引用的；如果字符串同时包含'k'和'v', 那么key和value均为弱引用。 Code1展示了怎么样创建一个包含weak pairs的弱表。

>	**Code 1** Creating a weak table in Lua.

	a = {} -- a regular table
	b = {} -- it's metatable
	setmetatable(a, b)
	b.__mode = "k" --makes 'a' weak

大部分弱引用的典型应用都涉及弱表。对于弱引用（和弱表）最相关的应用程序，我们强调如下：

- **循环数据结构的回收** -单纯的引用计数垃圾回收器是不能够回收循环应用的数据结构的。 根据Brownbridge[Brownbridge 1985], 这个缺点是开发弱引用的最初动机。 只要将一对循环引用至少一个平凡引用替换为弱引用，问题很容易就被克服了。随着跟踪垃圾收集器的到来，这个用法逐渐被废弃。
- **Cache** -对于一些频繁使用大数据结构的应用程序来讲，把这些数据结构驻留在内存中可以显著提高程序的效率。但是，这可能会加速内存消耗。弱表提供了一个简单的方案来实现一个自动管理的缓存，它可以只在内存足够的情况下才保留数据。

  根据literature[Ierusalimschy 2006, Jones et al. 1999], 一个使用常见使用cache的应用就是*memoized function（[记忆函数](https://en.wikipedia.org/wiki/Memoization)）* 。通过存储结果，可以使一个复杂的函数中必要的计算开销显著减少。当函数重新被以相同的参数调用时，它仅仅返回之前存储过的结果即可。在一个长期运行的应用中，*memoized function*所占用的内存可以增长到一个无法忍受的地步。在这种情况下，使用弱表(weak table)可以透明的只保存最近（也可能是最频繁）访问的值而不用牺牲内存的可用性。
- **Weak sets** -弱集合可以理解为一个对象的集合，这些对象与这个集合进行关联，但并不会产生一个到对象的引用。在对象必须被成组处理，却又不必干涉其生命周期的情况下，弱集合常被用作一个解决方案的实现。一个常见的例子是设计模式中的*观察者* 模式， 这种模式定义了一种在对象之间一对多的从属关系，当一个对象改变状态之后，它的所有从属都会被自动通知和更新[Ganna et al. 1995]. 此通知可以实现的关键在于需要让被观察的对象知道他有哪些观察者。在一个松耦合的应用程序中， 这些对观察者的引用不应该也不能阻止它们被回收。使用弱表来保存观察者对像并不会阻止它们被回收。
- **Finalization** -弱引用可以被当作一个通知的扩展形式用来通知客户程序对象已经被回收了，最终执行与这些事件相关联的例程（函数）。这被称作集装箱销毁与类实例销毁形成对比，类实例销毁是采用面向对象实现的[Hayes 1997, Jones et al. 1999]。
- **Property tables** -弱表可以让我们对一个对像增加任意属性，即他们可以表现为属性表。使用弱表来实现属性表所带来的益处依赖于一个事实，在大部分情况下，增加一个属性到一个对象并不需要改变对象的生命周期。例如，考虑 Figure 1. 在这个表中，每一个key都有一个对象的弱引用，每一个key所对应的value都有一个对这个对象的额外属性的平凡引用。如果key对对象的引用是平凡的，只要简单的插入一个新的key/value对就会阻止被key所引用的对象的回收。只有当key对对象的引用为弱引用时，对象才可以在不被客户程序使用时尽快回收。
![](1.png)


理论上，只要弱表中的key/value对中的key可以从弱表外的某个地方*直接或间接可达* ，这个key/value对就一定存在于弱表中。（如果key被一些外部对象引用他就是*直接可达* ，如果key被另一个key/value对中的value所引用，而这个value所对应的key是直接或间接可达的，那么这个key就是*间接可达* .）然而大多数编程语言的实现中，并不存在这一行为。当一个key/value对中的value字段直接或间接的引用了它的key, 就会在表内或不同的弱表中的两个元素之间形成环。Figure2 上描述的table展示了这个问题。 由于元素1的自引用（value引用key）和元素2，3之间之的环的存在，所有被这些对象（译者注：指的是元素1，2,3）引用的元素将永远不会被回收。即使没有环的存在，回收这些对象所经过的时间也将远超预期。考虑元素4和5，元素4的value有一个对元素5的key的引用。一般来说，只有当元素4被回收之后的循环中元素5才可以被回收。一个有n个元素组成的链的弱表完全被回收将会花费n的循环。有人可能认为如要把value从强引用改为弱引用将会对这个问题有帮助，遗憾的是，这是不正确的。考虑一个属性表，一个对象作为vaule只存在于这个表中。如果value对对象的引用是弱引用，这意味着这个对象将会被回收。但是，这个对象对应的key可能还依然处于活动中，依然有可能会用这个key在属性表中搜索这个其对应的value(对象)。
![](2.png)

例如，当弱表被*memoized functions*（记忆函数）用做缓存时也可能存在环。假如我们想创建一些常数函数：给一个值，创建一个函数，这个函数总是返回这个值。使用Lua语言的一个实现可能是这样：

>    
	function K(x)
		return function() return x end
	end

如果我们想记忆这个函数（以便对于最近处理过的值，我们可以不必重复创建这个函数），我们需要一个表来映身从x(key)到K(x)(value)。注意，value是一个函数，这个函数包含了x的引用。这样，key和value永远都不会被释放。

像Java和Lua都面临着弱表循环的问题。Java的**WeakHashMap** API有一份实现说明，“需要注意保证value对象不能直接或间接的强引用他们的key，以便这不会阻止key被丢弃”[SUN 2006]。
 
